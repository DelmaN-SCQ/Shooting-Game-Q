<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SGQ Beta</title>
<style>
  :root { --ui-bg: rgba(0,0,0,0.6); --accent: #2ecc71; }
  body { margin:0; background:#071019; font-family:Inter, Arial, sans-serif; color:#fff; overflow:hidden; }
  canvas { display:block; margin:0 auto; background:#000; }
  #ui {
    position: absolute; top:12px; left:50%; transform:translateX(-50%);
    width:340px; text-align:center; z-index:10;
    background: var(--ui-bg); padding:8px 12px; border-radius:10px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
  }
  #score { font-weight:700; font-size:20px; letter-spacing:0.5px; }
  #level { font-size:14px; opacity:0.9; margin-top:4px; }
  #health-wrap { margin-top:8px; height:18px; background:#333; border-radius:10px; overflow:hidden; }
  #health { height:100%; background:linear-gradient(90deg,#2ecc71,#27ae60); width:100%; transition:width 200ms linear; }
  #shield-ind { margin-top:6px; font-size:13px; color:#9dd7ff; min-height:18px; }
  /* Menu and overlays */
  #menu, #gameover {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    color:white; text-align:center; z-index:20;
    background: rgba(3,6,10,0.6); padding:30px; border-radius:12px; width:420px;
    box-shadow: 0 18px 40px rgba(0,0,0,0.7);
  }
  h1 { margin:0 0 10px 0; font-size:36px; letter-spacing:2px; }
  p.inst { margin:6px 0 18px 0; opacity:0.9; }
  button {
    appearance:none; border:0; background:#0b84ff; color:white; padding:10px 18px; border-radius:8px; font-size:16px;
    cursor:pointer; margin:6px;
  }
  button.secondary { background:#2e2e2e; }
  .small { font-size:13px; opacity:0.9; }
  /* Game over layout */
  #gameover h2 { font-size:28px; margin-bottom:12px; color:#ff6b6b; }
  #gameover .row { display:flex; justify-content:center; gap:10px; margin-top:10px; }
</style>
</head>
<body>
<div id="menu">
  <h1>Strzelanka Arcade</h1>
  <p class="inst">Strzał: <b>SPACJA</b> • Ruch: <b>Strzałki</b></p>
  <div><button id="startBtn">Start</button><button id="demoBtn" class="secondary">Demo</button></div>
  <p class="small">Zbieraj <span style="color:#2ecc71">zielone</span> → +HP, <span style="color:#9dd7ff">niebieskie</span> → tarcza (shield).</p>
</div>

<div id="ui" style="display:none;">
  <div id="score">Punkty: <span id="scoreVal">0</span></div>
  <div id="level">Poziom: <span id="levelVal">1</span></div>
  <div id="health-wrap"><div id="health"></div></div>
  <div id="shield-ind">Tarcza: <span id="shieldVal">Brak</span></div>
</div>

<div id="gameover" style="display:none;">
  <h2>Przegrałeś</h2>
  <p>Twój wynik: <b id="finalScore">0</b></p>
  <div class="row">
    <button id="restartBtn">Restart</button>
    <button id="toMenuBtn" class="secondary">Menu</button>
  </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/* ========= Konfiguracja i zasoby ========= */
// Ścieżka do sprite-sheet (pobierz plik i umieść obok index.html)
const SPRITE_SHEET = "sandbox:/mnt/data/spritesheet_32x32.png";

/* Ustawienia gry */
const CELL = 32; // rozmiar klatki w spricie (32x32)
const COLUMNS = 4; // ile kolumn w sheet (założyliśmy 4 w wierszu)
const ROWS = 5; // liczba wierszy - dopasuj jeśli inna
const CANVAS = document.getElementById("gameCanvas");
const ctx = CANVAS.getContext("2d");
resize();
window.addEventListener("resize", resize);

/* UI */
const ui = document.getElementById("ui");
const menu = document.getElementById("menu");
const gameover = document.getElementById("gameover");
const startBtn = document.getElementById("startBtn");
const demoBtn = document.getElementById("demoBtn");
const restartBtn = document.getElementById("restartBtn");
const toMenuBtn = document.getElementById("toMenuBtn");
const scoreVal = document.getElementById("scoreVal");
const levelVal = document.getElementById("levelVal");
const healthBar = document.getElementById("health");
const shieldVal = document.getElementById("shieldVal");
const finalScore = document.getElementById("finalScore");

/* Eventy menu */
startBtn.onclick = () => startGame(false);
demoBtn.onclick = () => startGame(true);
restartBtn.onclick = () => startGame(false);
toMenuBtn.onclick = () => { showMenu(); };

/* Sterowanie */
const keys = {};
addEventListener("keydown", (e) => { keys[e.key] = true; if(e.key===" " && gameRunning) shoot(); });
addEventListener("keyup", (e) => keys[e.key] = false);

/* Załaduj sprite-sheet */
const sprite = new Image();
sprite.src = SPRITE_SHEET;
sprite.onerror = () => {
  // jeśli ścieżka przez sandbox: niektóre przeglądarki nie załadują - wtedy informacja
  console.warn("Nie mogę załadować sprite-sheet z sandbox path. Upewnij się, że plik spritesheet_32x32.png jest w tym samym folderze co index.html lub popraw ścieżkę.");
};

/* ========= Obiekty gry ========= */
let gameRunning = false;
let demoMode = false;
let score = 0;
let level = 1;
let levelTick = 0;

const player = {
  x: 80, y: 0, width: 28, height: 28, speed: 6,
  lives: 3, maxLives: 5,
  shield: 0, shieldMax: 300, // shield timer (frames)
  spriteCell: {col:0,row:0} // gracz w komórce (0,0)
};

const bullets = [];
const enemies = [];
const powerups = [];
const particles = [];
let enemySpeed = 1.8;
let spawnTimer = 0;
let spawnInterval = 60; // frames

/* Mapa klatek w sprite-sheet (zakładamy układ 4x5) 
   Dostosuj jeśli Twój sprite-sheet ma inny porządek.
   Komentarze: (col,row) zaczynając od 0.
*/
const SPRITES = {
  player: {col:0,row:0},
  enemy1: {col:1,row:0},
  enemy2: {col:2,row:0},
  enemy3: {col:3,row:0},
  bullet: {col:0,row:1},
  bullet2: {col:1,row:1},
  power_hp: {col:2,row:1},    // zielone plus -> HP
  power_shield: {col:3,row:1},// niebieska tarcza -> shield
  fx1: {col:0,row:2},
  fx2: {col:1,row:2},
  fx3: {col:2,row:2},
  fx4: {col:3,row:2}
};

/* ========= Utility i pomocnicze funkcje ========= */
function resize(){
  CANVAS.width = innerWidth;
  CANVAS.height = innerHeight;
  // ustaw pozycję startową gracza
  player.x = CANVAS.width/2 - player.width/2;
  player.y = CANVAS.height - player.height - 40;
}

/* Rysuj klatkę z sprite-sheetu */
function drawSprite(col,row,dx,dy,dw,dh,flip=false){
  // kolumny/wiersze w sheet; zakładamy CELL x CELL
  if(!sprite.complete) return; // czekaj na załadunek
  const sx = col * CELL;
  const sy = row * CELL;
  if(!flip) ctx.drawImage(sprite, sx, sy, CELL, CELL, dx, dy, dw, dh);
  else {
    ctx.save();
    ctx.translate(dx+dw/2,0);
    ctx.scale(-1,1);
    ctx.drawImage(sprite, sx, sy, CELL, CELL, -dw/2, dy, dw, dh);
    ctx.restore();
  }
}

/* Tworzenie cząsteczek */
function spawnParticles(x,y,color,count=8){
  for(let i=0;i<count;i++){
    particles.push({
      x, y,
      vx: (Math.random()-0.5)*3,
      vy: (Math.random()-0.8)*3,
      r: Math.random()*2+1,
      life: 30 + Math.random()*20,
      color
    });
  }
}

/* ========= Mechanika gry ========= */
function spawnEnemy(){
  const w = 28 + Math.random()*34;
  const h = w;
  const x = Math.random()*(CANVAS.width - w);
  const hp = 1 + Math.floor(Math.random()*3); // 1..3 hp
  const type = Math.ceil(Math.random()*3); // typ 1..3
  const spriteMap = type===1 ? SPRITES.enemy1 : type===2 ? SPRITES.enemy2 : SPRITES.enemy3;
  enemies.push({x, y:-h-10, w, h, hp, maxHp:hp, type, spriteMap});
}

function spawnPowerup(){
  const size = 26;
  const x = Math.random()*(CANVAS.width - size);
  const isHp = Math.random() < 0.6; // częściej HP
  const kind = isHp ? "hp" : "shield";
  const map = isHp ? SPRITES.power_hp : SPRITES.power_shield;
  powerups.push({x, y:-size-10, size, kind, map});
}

function shoot(){
  const bW = 8, bH = 16;
  bullets.push({x: player.x + player.width/2 - bW/2, y: player.y - 6, w: bW, h: bH, vy: -10});
  spawnParticles(player.x + player.width/2, player.y, "#ffd76b", 6);
}

/* kolizja AABB */
function collide(a,b){ return a.x < b.x + (b.w||b.width) && a.x + (a.w||a.width) > b.x && a.y < b.y + (b.h||b.height) && a.y + (a.h||a.height) > b.y; }

/* Reset stanu gry */
function resetGame(){
  bullets.length = 0; enemies.length = 0; powerups.length = 0; particles.length = 0;
  score = 0; level = 1; levelTick = 0; enemySpeed = 1.8; spawnInterval = 60;
  player.lives = 3; player.shield = 0;
  updateUI();
}

/* Start / stop / menu */
function startGame(isDemo){
  demoMode = !!isDemo;
  menu.style.display = "none";
  ui.style.display = "block";
  gameover.style.display = "none";
  gameRunning = true;
  resetGame();
  // jeśli demo: daj więcej wrogów by pokazać rozgrywkę
  if(demoMode){ spawnInterval = 40; enemySpeed = 2.2; }
}

function showMenu(){
  menu.style.display = "block";
  ui.style.display = "none";
  gameover.style.display = "none";
  gameRunning = false;
}

/* game over overlay */
function gameOver(){
  gameRunning = false;
  finalScore.textContent = score;
  gameover.style.display = "block";
}

/* UI update */
function updateUI(){
  scoreVal.textContent = score;
  levelVal.textContent = level;
  const hpPerc = Math.max(0, Math.min(100, (player.lives/player.maxLives)*100));
  healthBar.style.width = hpPerc + "%";
  shieldVal.textContent = player.shield > 0 ? "Aktywna" : "Brak";
}

/* ========= Pętla gry ========= */
function update(){
  if(!gameRunning) return;
  // poziom / trudność
  levelTick++;
  if(levelTick > 1200){ level++; levelTick = 0; enemySpeed += 0.3; spawnInterval = Math.max(20, spawnInterval - 6); }

  // sterowanie gracza
  if(keys["ArrowLeft"] && player.x > 6) player.x -= player.speed;
  if(keys["ArrowRight"] && player.x + player.width < CANVAS.width - 6) player.x += player.speed;
  if(keys["ArrowUp"] && player.y > 6) player.y -= player.speed;
  if(keys["ArrowDown"] && player.y + player.height < CANVAS.height - 6) player.y += player.speed;

  // strzelanie: spacja obsłużona eventem keydown -> shoot()

  // aktualizacja pocisków
  for(let i = bullets.length-1; i >= 0; i--){
    const b = bullets[i];
    b.y += b.vy;
    if(b.y + b.h < 0) bullets.splice(i,1);
  }

  // spawn wrogów / powerupów
  spawnTimer++;
  if(spawnTimer >= spawnInterval){
    spawnTimer = 0;
    if(Math.random() < 0.12) spawnPowerup();
    spawnEnemy();
  }

  // update wrogów
  for(let i = enemies.length-1; i >= 0; i--){
    const e = enemies[i];
    e.y += enemySpeed;
    // kolizja z pociskami
    for(let j = bullets.length-1; j >= 0; j--){
      const b = bullets[j];
      if(collide({x:b.x,y:b.y,w:b.w,h:b.h},{x:e.x,y:e.y,width:e.w,height:e.h})){
        bullets.splice(j,1);
        e.hp--;
        spawnParticles(e.x + e.w/2, e.y + e.h/2, "#ffb54d", 10);
        if(e.hp <= 0){
          score += 10;
          enemies.splice(i,1);
        }
        break;
      }
    }
    // kolizja z graczem
    if(collide(player, {x:e.x,y:e.y,width:e.w,height:e.h})){
      // jeśli tarcza aktywna, zniszcz wroga i nie zabieraj życia
      if(player.shield > 0){
        enemies.splice(i,1);
        spawnParticles(e.x + e.w/2, e.y + e.h/2, "#9dd7ff", 12);
      } else {
        enemies.splice(i,1);
        player.lives--;
        spawnParticles(player.x + player.width/2, player.y + player.height/2, "#ff7979", 16);
        if(player.lives <= 0){
          updateUI();
          gameOver();
          return;
        }
      }
    }
    if(e.y > CANVAS.height + 60) enemies.splice(i,1);
  }

  // power-upy
  for(let i = powerups.length-1; i >= 0; i--){
    const p = powerups[i];
    p.y += 2.4;
    if(collide(player, {x:p.x,y:p.y,width:p.size,height:p.size})){
      // zielone = hp, niebieskie = shield
      if(p.kind === "hp"){
        player.lives = Math.min(player.maxLives, player.lives + 1);
        spawnParticles(player.x + player.width/2, player.y + player.height/2, "#2ecc71", 12);
      } else {
        player.shield = player.shieldMax; // aktywuj tarczę
        spawnParticles(player.x + player.width/2, player.y + player.height/2, "#9dd7ff", 12);
      }
      powerups.splice(i,1);
    } else if(p.y > CANVAS.height + 20) {
      powerups.splice(i,1);
    }
  }

  // cząsteczki
  for(let i = particles.length-1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.life--;
    if(p.life <= 0) particles.splice(i,1);
  }

  // tarcza maleje w czasie
  if(player.shield > 0) player.shield--;

  // UI
  updateUI();
}

/* ========= Rysowanie ========= */
function draw(){
  // tło gradient + gwiazdy
  ctx.fillStyle = "#000814";
  ctx.fillRect(0,0,CANVAS.width,CANVAS.height);
  // gwiazdy (prosty efekt)
  ctx.fillStyle = "#ffffff";
  for(let i=0;i<120;i++){
    // prosty pseudo-random fixed stars - niewrażliwy sposób, generujemy na podstaw długości arrays
  }
  // prosty efekt gwiazd (na potrzeby wydajności rysujemy kilka)
  for(let i=0;i<150;i++){
    ctx.globalAlpha = 0.6;
    ctx.fillRect((i*97)%CANVAS.width, (i*59)%CANVAS.height, (i%3)+1, (i%2)+1);
  }
  ctx.globalAlpha = 1;

  if(!gameRunning){
    // jeśli menu/koniec gry, możemy narysować statek w tle
    // draw sprites faintly
    drawSprite(SPRITES.player.col, SPRITES.player.row, CANVAS.width/2 - 24, CANVAS.height/2 + 60, 48, 48);
    return;
  }

  // gracz (sprite)
  drawSprite(SPRITES.player.col, SPRITES.player.row, player.x, player.y, player.width, player.height);

  // pociski
  for(const b of bullets){
    // rysuj sprite pocisku jeśli dostępny, inaczej prostokąt
    drawSprite(SPRITES.bullet.col, SPRITES.bullet.row, b.x, b.y, b.w, b.h);
  }

  // wrogowie + hp bar
  for(const e of enemies){
    drawSprite(e.spriteMap.col, e.spriteMap.row, e.x, e.y, e.w, e.h);
    // pasek HP nad wrogiem
    const barW = e.w;
    const hpPerc = Math.max(0, e.hp / e.maxHp);
    ctx.fillStyle = "#333";
    ctx.fillRect(e.x, e.y - 8, barW, 5);
    ctx.fillStyle = "#ff6b6b";
    ctx.fillRect(e.x, e.y - 8, barW * hpPerc, 5);
    ctx.strokeStyle = "#000";
    ctx.strokeRect(e.x, e.y - 8, barW, 5);
  }

  // powerups
  for(const p of powerups){
    drawSprite(p.map.col, p.map.row, p.x, p.y, p.size, p.size);
  }

  // particles
  for(const p of particles){
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();
  }

  // overlay: shield indicator around player
  if(player.shield > 0){
    ctx.strokeStyle = "rgba(157,215,255,0.7)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.ellipse(player.x + player.width/2, player.y + player.height/2, player.width, player.height, 0, 0, Math.PI*2);
    ctx.stroke();
  }
}

/* ========= Główna pętla ========= */
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

/* ========= Drobne poprawki: poprawny mapping powerups po załadowaniu sheet ========= */
sprite.onload = () => {
  // jeśli chcesz możesz tu dopasować mapping w SPRITES do rzeczywistego układu sprite-sheetu.
  // W moim kodzie zakładam, że powerup HP = (2,1) i shield = (3,1).
  // Jeśli twój sheet jest inaczej, zaktualizuj SPRITES.power_hp / power_shield.
  // Przykładowo:
  // SPRITES.power_hp = {col:2,row:1}; SPRITES.power_shield = {col:3,row:1};
  console.log("Sprite sheet załadowany.");
};

/* ========= Helper: dostosuj powerup.map przed spawnem (mapowanie komórek) ========= */
function spawnPowerup(){
  const size = 26;
  const x = Math.random()*(CANVAS.width - size);
  const isHp = Math.random() < 0.6;
  const kind = isHp ? "hp" : "shield";
  const map = isHp ? SPRITES.power_hp : SPRITES.power_shield;
  // zapisz mapę także jako 'map' by draw() mogło użyć:
  powerups.push({x, y:-size-10, size, kind, map});
}

/* ========= Koniec pliku ========= */
</script>
</body>
</html>
